{
  "hash": "26934dab5f9fab1098769c54b1611059",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Take-home Exercise 2: Discovering impacts of COVID-19 on Thailand tourism economy at the province level using spatial and spatio-temporal statistics\"\nauthor: \"Fu Wanqian\"\npublished: \"September 10, 2024\"\nmodified: \"September 22, 2024\"\nexecute: \n  echo: true\n  warning: false\n  freeze: true\n  cache: true\n  eval: false\nfotmat:\n  html:\n    code-fold: true\n---\n\n\n# 1 Set the Scene\n\nTourism is a major contributor to Thailand’s economy, making up about 20% of GDP. In 2019, the industry generated 90 billion US$, but due to the COVID-19 pandemic, this dropped to 24 billion US$ in 2020. Since September 2021, tourism revenues have been gradually recovering. However, the economic benefits are not evenly spread across the country, with key provinces like Bangkok, Phuket, Chiang Mai, Sukhothai, and Phetchaburi dominating the sector. In this exercise,we need to explore whether the tourism economy shows spatial and spatio-temporal dependence, and if so, identify clusters, outliers, and emerging hot or cold spots.\n\n# 2 Setting the Analytical Tools\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, spdep, tmap, tidyverse, patchwork,spacetime)\n```\n:::\n\n\n# 3 Data Collection\n\nTwo data sets will be used in this exercise:\n\n-   [Thailand Domestic Tourism Statistics](https://www.kaggle.com/datasets/thaweewatboy/thailand-domestic-tourism-statistics) at Kaggle. This dataset contains statistics on domestic tourism in Thailand from Jan 2019 to Feb 2023, broken down by province. The datasetincludes information on the number of tourists, the occupancy rate, and the profits generated by tourism in each province, as wel as thenationality of the tourists.\n\n-   [Thailand - Subnational Administrative Boundaries](https://data.humdata.org/dataset/cod-ab-tha?) at HDX. This dataset has been used in the last exercise.\n\nUse below codes to import these two raw datasets.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nthai_province <- st_read(dsn=\"data/geospatial\", layer = 'tha_admbnda_adm1_rtsd_20220121')\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nthai_tour <- read_csv(\"data/aspatial/thailand_domestic_tourism_2019_2023_ver2.csv\")\nhead(thai_tour,5)\n```\n:::\n\n\nWe notice that there are 8 kinds of values in Variable, so we transforms the Variable column values into separate variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nthai_tour_wide <- thai_tour %>%\n  pivot_wider(names_from = variable, values_from = value)\nsaveRDS(thai_tour_wide,\"data/aspatial/thai_tour_wide.rds\")\n```\n:::\n\n\nAnd use below codes to generate a spatio-temporal dataset of thai tourism economy indicator.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# change the column name to get identifier\ncolnames(thai_tour_wide)[colnames(thai_tour_wide) == \"province_eng\"] <- \"ADM1_EN\"\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#align the format\nthai_tour_wide$ADM1_EN <- tolower(thai_tour_wide$ADM1_EN)\nthai_province$ADM1_EN <- tolower(thai_province$ADM1_EN)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## thai_tour_spt <- spacetime(thai_tour_wide, thai_province,\n ##                      .loc_col = \"ADM1_EN\",\n  ##                     .time_col = \"date\")\n## is_spacetime_cube(thai_tour_spt)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n##saveRDS(thai_tour_spt,\"data/aspatial/thai_tour_spt.rds\")\n```\n:::\n\n\n# 4 Global spatial autocorrelation analysis\n\n## 4.1 Data preparation\n\n### 4.1.1 Convert multi polygon to polygon\n\nFrom below map, We can see that the thai_province geometry data is multipolygon, which may cause problems when calculating centroids. These smaller regions might shift the calculated centroid away from the province's main landmass.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(thai_province) +\n  tm_polygons()\n```\n:::\n\n\nUse the code below to convert multipolygon to polygon and select the largest one to represent the province.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nthai_province_polygon<- thai_province %>%\n  st_cast(\"POLYGON\")%>%\n  mutate(area=st_area(.))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nthai_province_cleaned<-thai_province_polygon%>%\n  group_by(ADM1_EN)%>%\n  filter(area == max(area))%>%\n  ungroup()%>%\n  select(-area)%>%\n  select(ADM1_EN)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(thai_province_cleaned) +\n  tm_polygons()\n```\n:::\n\n\n### 4.1.2 Perform relational join\n\nThe code chunk below will be used to update the attribute table of thailand’s SpatialPolygonsDataFrame with the attribute fields of thai_tour_wide dataframe.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nthai_join <- left_join(thai_province_cleaned,thai_tour_wide) %>%\n  select(1:3, 12)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nany(is.na(thai_join))\n```\n:::\n\n\nThere are NA value in the dataframe after join. We infer that the NA is due to a name mismatch in the ADM1_EN column. Use below codes to check and align all the name.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get unique names from both datasets\nbd_names <- unique(thai_province_cleaned$ADM1_EN)\ntourism_names <- unique(thai_tour_wide$ADM1_EN)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Identify names in thai_province_cleaned not present in thai_tour_wide\nmismatched_names <- setdiff(bd_names, tourism_names)\nmismatched_names\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmismatched_names2 <- setdiff(tourism_names, bd_names)\nmismatched_names2\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nname_fixes <- c(\n  \"lop buri\" = \"lopburi\",\n  \"chai nat\" = \"chainat\",\n  \"chon buri\" = \"chonburi\",\n  \"prachin buri\" = \"prachinburi\",\n  \"buri ram\" = \"buriram\",\n  \"si sa ket\" = \"sisaket\",\n  \"nong bua lam phu\" = \"nong bua lamphu\",\n  \"phangnga\" = \"phang nga\"\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Apply the fixes to the 'ADM1_EN' column in thai_province_cleaned\nthai_province_cleaned$ADM1_EN <- sapply(thai_province_cleaned$ADM1_EN, function(x) {\n  if (x %in% names(name_fixes)) {\n    name_fixes[x] \n  } else {\n    x \n  }\n})\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nthai_last <- left_join(thai_province_cleaned,thai_tour_wide) %>%\n  select(1:3, 12)\n\nany(is.na(thai_last))\n\ncolSums(is.na(thai_last))\n```\n:::\n\n\n### 4.1.3 Calculate yearly revenue\n\n\n::: {.cell}\n\n```{.r .cell-code}\nthai_last <- thai_last %>%\n  mutate(year = format(as.Date(date), \"%Y\"))  \nthai_last_summary <- thai_last %>%\n  group_by(ADM1_EN, year) %>%\n  summarise(revenue_all = sum(revenue_all, na.rm = TRUE))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsaveRDS(thai_last_summary,\"data/aspatial/thai_last_summary.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nthai_summary2019 <- thai_last_summary %>%\n  filter(year == 2019)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nthai_summary2021 <- thai_last_summary %>%\n  filter(year == 2021)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nthai_summary2023 <- thai_last_summary %>%\n  filter(year == 2023)\n```\n:::\n\n\n## 4.3 Global Measures of Spatial Autocorrelation\n\n![](images/1.png)\n\nFrom the figure, the revenue of the Thai tourism industry changed significantly before and after covid-19. The revenue from the tourism industry has been gradually recovering since September 2021. Therefore, we selected the years 2019, 2021, and 2023 to represent different periods of COVID-19. For these years, we will compute global spatial autocorrelation statistics and perform a spatial complete randomness test for global spatial autocorrelation.\n\n### 4.3.1 Computing Contiguity Spatial Weights\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q2019 <- poly2nb(thai_summary2019, queen=TRUE, snap = 1)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(wm_q2019)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q2021 <- poly2nb(thai_summary2021, queen=TRUE, snap = 1)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q2023 <- poly2nb(thai_summary2023, queen=TRUE, snap = 1)\n```\n:::\n\n\n### 4.3.2 Visualize Contiguity Spatial Weights\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlongitude <- map_dbl(thai_summary2023$geometry, ~st_centroid(.x)[[1]])\nlatitude <- map_dbl(thai_summary2023$geometry, ~st_centroid(.x)[[2]])\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords <- cbind(longitude, latitude)\nhead(coords)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(thai_summary2023$geometry, border=\"lightgrey\")\nplot(wm_q, coords, pch = 19, cex = 0.2, add = TRUE, col = \"red\")\n```\n:::\n\n\n### 4.3.3 Convert the neighbors list to a weights list\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrswm_q2019 <- nb2listw(wm_q2019, \n                   style=\"W\", \n                   zero.policy = TRUE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrswm_q2021 <- nb2listw(wm_q2021, \n                   style=\"W\", \n                   zero.policy = TRUE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrswm_q2023 <- nb2listw(wm_q2023, \n                   style=\"W\", \n                   zero.policy = TRUE)\n```\n:::\n\n\n### 4.3.4 Global Measures of Spatial Autocorrelation: Moran’s I\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMorans_I2019 <- moran.test(thai_summary2019$revenue_all, \n           listw=rswm_q2019)\nprint(Morans_I2019)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nMorans_I2021 <- moran.test(thai_summary2021$revenue_all, \n           listw=rswm_q2021)\nprint(Morans_I2021)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nMorans_I2023 <- moran.test(thai_summary2023$revenue_all, \n           listw=rswm_q2023)\nprint(Morans_I2023)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}